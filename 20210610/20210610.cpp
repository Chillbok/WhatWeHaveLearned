#include <iostream>
using namespace std;

int main()
{
    /*
    주소에 *을 붙이면 값이 되고,
    값에 &을 붙이면 주소가 된다.
    */

    /*
    동적 할당. 더블포인터(이중배열)
    함수포인터

    배열선언(우리가 지금까지 배운 것)은 정적 할당이다.

    int a[50] = 딱 50개가 만들어진다.

    동적 할당은 배열에서 많이 사용한다.
    동적 할당은 메모리의 할당을 동적으로 해주는 것이다.
    동적 할당을 사용하기 위해서는 [생성 --> 할당 --> 사용 --> 제거]의 순서를 따라야 한다.
    */
    int idx = 5;

    //int num[idx] = {1, 2, 3, 4, 5}; --> x
    //1. num[idx] 실행 전에 이미 만들어져 있어야 하는데 / 20byte
    //2. int idx        : 4byte를 할당해야 한다. 컴파일단계(실행 전) / 4byte
    //3. int = 5        : 실행 중에 알 수 있다.(런타임 단계)

    /*
    단순하게 생각하면, 메모리를 할당하는 건 프로그램을 실행 전에 하고,
    메모리에 값을 넣는 것은 프로그램을 실행 중에 한다.

    따라서 int idx = 5와 int num[idx]는 실행 전에 하는데, 이 num[idx]에
    값 {1, 2, 3, 4, 5}을 집어넣는 것은 프로그램 실행 후이다.

    동적 할당의 역할은 이 순서(메모리에 할당 --> 값 넣기)를
    (값 넣기 --> 메모리에 할당)의 형태로 바꾸어 주는 것이다.
    */

    /*
    동적 할당을 하려면 주소값에 접근해서 그 영역을 새로 할당해야 한다.
    배열 생성: new 자료형[크기];
    배열 제거: delete[]
    */
    //int* num = new /*자료형(포인터 자료형과 동일)*/int[/*배열 갯수*/];

    int* num = new int[idx];//생성

    int i = 0;
    for (i = 0; i < idx; i++)
    {
        num[i] = i + 1;
        cout << num[i] << endl;
    }
    
    delete[] num; //배열을 제거
    /*
    자동할당 메모리의 경우에는 자동으로 제거까지 해준다.
    하지만 이렇게 동적할당을 한 경우에는 자동으로 제거를 해주지 못하기 때문에, 프로그래머가 직접 배열을 제거하는 과정까지 해주어야 한다.
    */
    
    return 0;
}



/*
주소에 *을 붙이면 값이 되고,
값에 &을 붙이면 주소가 된다.
*/

/*
동적 할당. 더블포인터(이중배열)
함수포인터

배열선언(우리가 지금까지 배운 것)은 정적 할당이다.

int a[50] = 딱 50개가 만들어진다.

동적 할당은 배열에서 많이 사용한다.
동적 할당은 메모리의 할당을 동적으로 해주는 것이다.
*/