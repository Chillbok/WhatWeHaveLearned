# API

***

<br>
<br>

# 목차

***

<details>
<summary>눌러서 목차 열기</summary>

</details>

<br>
<br>

# 1. API란?

***

> Application Programming Interface

클래스와 비슷한 개념이다.

API 안에는 다양한 함수들이 존재한다.

## 1.1. API가 프로그램에서 가지는 의미는?

***

게임을 만들 때에는 DirectX(이것도 클래스)를 사용한다.

DX 안은 여러개의 API들로 이루어져있는데, 이 API들은 MFC에 의해 묶여진다.

> MFC: Microsoft Foundation Class

<br>
<br>

# 2. 입출력하는 위치

---

입출력을 하는 곳은 `case WM_PAINT`이다.

이렇게 구성되어 있다:

```C++
case WM_PAINT:
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);
    //TODO: 여기에 hdc를 사용하는 그리기 소스를 추가합니다...
    EndPaint(hWnd, &ps);
}
```

<br>
<br>

# 3. API에서의 입출력

---

## 3.1. `TextOut`

---

API에서 출력을 할 때에는 여러가지 방법이 있다.

그 중 첫번째 방법은 바로 `TextOut`를 사용하는 것이다.

다음은 예시이다:

```C++
TextOut(HDC hdc, int X, int Y, LPCWSTR lpstring, int c);
```

**여기에서 hdc는, 화면 출력에 대한 정보를 담고 있는 구조체이다.**

출력에 필요한 정보를 가져올 수 있는 데이터 구조체이다.

**int 형태의 변수인 X와 Y는 텍스트가 출력될 위치이다.**

**lstring은 출력될 문구이다.**

**c는 몇 바이트(byte)를 출력할 것인지를 적는 곳이다.**

이제 실전에서 응용해보도록 하자.

### 3.1.1. 응용

---

지금까지 배운 것을 바탕으로, 아래처럼 작성해보자.

코드는 앞에서 말했다시피, `case WM_PAINT:`의 `//TODO:` 아래에 작성하도록 한다.

```C++
TextOut(hdc, 100, 100, "Hello World", 10);
```

하지만 위와 같이 작성했을 때에는 제대로 작성되지 않을 것이다. 그 이유는 바로 `"Hello World"`에 있다.

`C++`를 비롯한 C언어 계열에서, 딱히 자료형을 지정해주지 않는 한 ""는 `const char*` 자료형의 형태로 출력된다. 따라서 이 경우에는, `"Hello World"`는 `TEXT("")`를 이용해서 출력해야 한다.

이것을 적용한다면 아래와 같이 변한다:

```C++
TextOut(hdc, 100, 100, TEXT("Hello World"), 10);
```

<br>

## 3.2. `TCHAR const *str =`

---

```C++
TCHAR* str = TEXT("Hello World");
```

위처럼 작성할 때에는, "Hello World`가 결과적으로 출력된다.

이전에, 솔루션 속성에서 \[구성 설정 -> 고급 -> 문자 집합\] 문자 집합 설정을 "유니코드 문자 집합 사용"으로 바꾸었을 것이다. 참고로, 기본 설정은 "멀티바이트 문자 집합 사용"이다.

그렇다면, 둘의 차이는 무엇인가? 바로 문자를 몇 `byte`로 받아들이냐의 차이이다.

다음 표를 보라.

|문자 집합 형식|영어(byte)|한글(byte)|
|:---:|:---:|:---:|
|멀티바이트|1|2|
|유니코드|2|2|

위 표에서 알 수 있다시피, 멀티바이트는 영어와 한글을 받아들이는 `byte` 수가 다르지만, 유니코드는 무조건 2 `byte`로 받아들인다.

따라서 효율 면에서 따져본다면 멀티바이트 문자 집합이 훨씬 좋을 것이다. 그렇다면 어째서 유니코드를 사용하는가?

주석을 달아야 하기 때문이다. 자세한 점은 이후에 기회가 있다면 설명하겠지만, 만약 유니코드가 아닌 방식을 사용하는 경우, 한글 주석을 달았을 때, 파일을 옮기는 등의 행위를 하는 경우 한글이 모두 깨진 상태로 나올 수 있다.

따라서, 유니코드로 설정을 미리 바꿔놓는 것이 좋을 것이다.

하지만, 가끔 멀티바이트 문자 집합을 사용해야 하는 경우가 있다. 그런 경우에는, `tchar`를 사용해주도록 한다.

`tchar`는 유니코드 내에서 멀티바이트를 지원하도록 하는 예약어이다. 해당하는 헤더파일을 `#include`를 통해 선언해주어야 하지만, 기본적으로 비주얼 스튜디오 2019 기준으로는 솔루션 생성 시 기본적으로 선언해주기 때문에 아직은 딱히 신경 쓸 필요는 없다.

사용법은 맨 처음 작성한 것과 같다.

```C++
TCHAR const *str = TEXT("Hello World");
```

위와 같이 작성했을 때, 결과적으로 `Hello World`가 출력되게 된다.

단, 여기에서 `const`를 추가해 상수 취급을 하는 것을 잊지 말도록 하자.


<br>

## 3.3. `strcat`, `strlen`

---

`LPCWSTR`의 `W`: Wide
`LPCTSTR`의 `T`: `tchar`의 `t`

API에서 출력을 하기 위한 세번째 방법은 바로 `LPCWSTR(LPCTSTR)`을 사용하는 것이다.

바로 위에 적혀 있듯이, `LPCWSTR`의 `W`는 "넓은"을 의미하는 `Wide`의 줄임말이며, `LPCTSTR`의 `T`는 앞서 배운 `tchar`의 `t`와 동일하다.

사용법은 다음과 같다:

```C++
SPCWSTR str1;
str1 = TEXT("Hello ");

SPCWSTR str2;
str2 = TEXT("World");
```

위와 같이 문자열들을 선언하고, 문자를 대입한다. 그렇다면, 이 문자열들을 어떻게 출력해야 하는가?

문자열을 파악하기 위해서는 다음 관련 함수들을 잘 이용해야 한다:

> `strcat`: 문자열끼리 연결
> `strlen`: 문자열의 길이(바이트) 파악

위에서 선언한 `str1`과 `str2`를 그대로 사용한다는 가정 하에, `strcat`과 `strlen`을 사용해보자.

```C++
int a = lstrlen(str1);
TextOut(hdc, 100, 100, str3, lstrlen(str1));
```

<br>
<br>

# 4. API에서 그림 그리기

---

우리가 지금까지 배운 콘솔과 이제부터 배울 API의 가장 큰 차이는, 드디어 "그래픽"의 개념이 들어간다는 것이다.

지금부터 해볼 것은, API 함수를 기반으로 여러가지 도형을 그려보는 것이다.

## 4.1. API에서 색을 16진수로 표현하기

---

일반적으로 우리가 색의 조합을 표현할 때에는, `RGB`라고 말한다. 각각 <span style="color:red>빨간색</span>, <span style="color:green">초록색</span>, <span style="color:blue">파란색</span>을 의미하는 영단어의 맨 앞글자이며, 일반적인 상황에서 표기할 때에도 위 순서대로 적는다.

**API에서는 다르다.**

API에서는 `RGB`가 아니라, `BGR`로 표현한다. `RGB`를 거꾸로 바꾸어 쓴다고 기억하면 된다. (이유는...? 왜인지는 모르겠지만 일단은 그렇게 쓴다고 한다)

따라서, RGB를 16진수로 표현할 때에도 파랑, 초록, 빨강 순서대로 값을 작성하면 된다.

이쯤 되면 무언가 이상하다는 것을 알았을 것이다. `RGB` 값만 나열하는 경우에는 3개의 값만이 존재한다. 따라서, 3`byte`라고 할 수 있다. 하지만, 중요한 점은 프로그래밍에는 3`byte`가 존재하지 않는다.

따라서, 프로그램에서 `RGB`값을 표현하기 위해서는 특수한 방식을 사용해야 한다.

**2가지 방법이 있다:**

> 1. XBGR
> 2. ABGR

`XBGR`은 앞 1byte를 비우고, 뒤에 BGR을 입력하는 방식이다.

`ABGR`은 앞에 알파값을 채우고, 뒤에 BGR을 입력하는 방식이다. `ABGR`의 `A`를 `Alpha`의 약자로 보면 될 것이다.

이 둘 중 API에서 더 많이 사용되는 방식은 `ABGR`이다.

<br>

## 4.2. 점 찍기

---

> 점을 확대하면, 원이 나타난다. 그리고 원을 축소하면, 점이 나타난다.
> 점은 하나만 찍으면 점이지만, 점을 여러개 이어서 찍으면 선이 된다.
> 그리고 그 선을 여러번 이으면 면이 된다.

```C++
SetPixel(HDC hdc, int x, int y, COLORREF);
```

위와 같이 표현한다.

`COLORREF`에는 **16진수**로 표현한 RGB값을 넣어주도록 한다. [4.1. API에서 색을 16진수로 표현하기](#41-api에서-색을-16진수로-표현하기)에서, `ABGR`방식을 더 자주 사용한다고 했었다. 그러니 `ABGR` 방식을 이용해서 위의 식에 맞추어 표현해보자.

```C++
SetPixel(hdc, 100, 100, 0x0000FF);
```

이렇게 작성하면, 1픽셀짜리 빨간색 점이 가로 좌표가 100, 세로 좌표가 100인 위치에 찍히게 된다.

거의 보이지 않기 때문에 크게 확대해서 보아야 할 것이다.

<br>

## 4.3. 선 그리기

---

앞서 말했듯이, 점을 하나만 찍으면 점이지만, 점을 여러개 이어서 찍으면 선이 된다. 따라서, 선을 긋기 위해서는 점을 여러번 찍으면 된다.

반복문을 응용하면, 쉽고 짧게 적을 수 있다.

```C++
int i = 0;

for (i = 0; i < 400; i++)
{
    Set Pixel(hdc, 100 + i, 100, 0x0000FF);
}
```

이렇게 작성한다면, 가로축과 평행한, 400픽셀 만큼의 길이를 가진 빨간색 선이 그어질 것이다.

<br>

## 4.4. 도형 그리기

---

### 4.4.1. 네모 그리기

---

네모를 그릴 때에는 `Rectangle` 함수를 사용하도록 한다.

다음과 같이 사용한다:

```C++
Rectangle(HDC hdc, (LEFT, TOP), (RIGHT, BOTTOM));
```

이제 본격적으로 그려보도록 하자.

```C++
int x, y, size;
x = 500;
y = 100;
size = 300;
Rectangle(hdc, x, y, x + size, y + size);
```

위 식대로 작성한다면, 가로세로 길이가 300픽셀인 정사각형이 그려진다.

<br>

### 4.4.2. 원 그리기

---

원을 그릴 때에는 `Ellipse` 함수를 사용하도록 한다.

사용법은 `Rectangle` 함수와 동일하다.

```C++
Rectangle(HDC hdc, (LEFT, TOP), (RIGHT, BOTTOM));
```

좌표의 기준을 어떻게 적어야 할지 헷갈릴 수도 있다. 이 문제는 같은 좌표를 대입한 사각형을 그리면 바로 해결된다.

원의 원점을 지나는 지름 중 가로축에 평행한 선과 세로축에 평행한 선을 생각하며 좌표를 작성하면, 쉽게 쓸 수 있을 것이다.

#### 4.4.2.1. 도형함수를 이용해 그린 도형 안쪽은 비어있지 않다

---

먼저 네모를 그리고, 원을 그려보자.

이전에 했던 것과 동일하게, 가로 세로 길이가 모두 300픽셀인 도형을 그려보자.

```C++
int x, y, size;
x = 500;
y = 100;
size = 300;
Rectangle(hdc, x, y, x + size, y + size);
Ellipse(hdc, x, y, x + size, y + size);
```

그렇다면 네모 안에 딱 맞추어진 원이 그려졌을 것이다.

이제 반대로, 원을 그리고 네모를 그려보자.

```C++
int , y, size;
x = 500;
y = 100;
size = 300;

Ellipse(hdc, x, y, x + size, y + size);
Rectangle(hdc, x, y, x + size, y + size);
```

이번에는, 먼저 그렸던 원이 사라진 것을 확인할 수 있다. 여기에서 하나의 중요한 사실을 알 수 있다.

> 도형함수를 이용해 그린 도형의 안쪽은 비어있는 것이 아니라, 흰색으로 칠해져있다.

<br>

### 4.4.3. 심화과정-다비드의 별 그리기

---


