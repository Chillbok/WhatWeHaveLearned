# 1. 입출력

*****

## 1.1. 입출력을 사용하기 위한 입출력 헤더파일

*****

### 1.1.1. C

*****

`stdio.h` __:__ 인클루드(포함)

#### 1.1.1.1. 사용법

*****

```C
#include "stdio.h"
```

### 1.1.2. C++

*****

`iostream.h` __:__ 인클루드

#### 1.1.2.1. 사용법

*****

```C++
#include <iostream>
```

# 2. C와 C++에서 모두 사용하는 것들

*****

## 2.1. 이스케이프 시퀸스

*****

### 2.1.1. 이스케이프 시퀸스란?

*****

> `\?` 형태로 큰따옴표 안에 들어가는 예약어로, 대표적인 이스케이프 시퀸스로는
> `\t`, `\n`, `\v` 등이 있다.

### 2.1.2. \t

*****

"Tab"을 사용해주는 이스케이프 시퀸스이다.

```C++
#include <iostream>
using namespace std;

int main()
{
    cout << "이스케이프\t시퀸스";
    
    return 0;
}
```

사용하면 다음과 같이 출력된다.

```txt
이스케이프  시퀸스
```

### 2.1.3. \n

*****

줄바꿈 기능을 위해 사용하는 이스케이프 시퀸스이다.

Cpp에서는 보통 `endl`을 더욱 많이 사용한다.

```C++
#include <iostream>
using namespace std;

int main()
{
    cout << "이스케이프\n시퀸스";

    return 0;
}
```

출력 결과는 다음과 같다.

```txt
이스케이프
시퀸스
```

## 2.2. 서식문자(서식 지정자)

*****

### 2.2.1. 형태

*****

`%?`의 형태로 출력한다. `?` 부분에 서식문자를 구분하는 알파벳이 들어간다.

### 2.2.2. 자주 사용되는 서식문자

*****

#### 2.2.2.1. d, i

*****

십진수형 정수를 출력할 때에 사용한다.

`d`와 `i`는 동일한 위치에 사용된다.

```C
#include "stdio.h"

int main()
{
	printf("%d", 1);

	return 0;
}
```

다음은 결과이다.

```txt
1
```

#### 2.2.2.2. s

*****

문자열을 출력할 때에 사용한다.

```C
#include "stdio.h"

int main()
{
	printf("%s", "hello world");

	return 0;
}
```

다음은 결과이다.

```txt
hello world
```

#### 2.2.2.3. f

*****

십진수형 실수를 출력할 때 사용한다.

```C
#include "stdio.h"

int main()
{
	printf("%f", 1.45);

	return 0;
}
```

다음은 결과이다.

```txt
1.450000
```


# 3. C에서의 입출력

*****

출력은 안에 이미 값이 있기 때문에 얼마만큼을(크기) 출력하면 되는가에 대해서 미리 알 수 있다. 따라서 출력만 하는 것은 그렇게 어렵지 않다.

하지만 입력이 함께 사용되는 경우 난이도가 올라간다.

아이디를 만든다고 가정해보자. 수십, 수백명의 유저가 각자가 원하는 아이디를 만들 것이다. 심지어 그 아이디는 번호가 들어갈 수도 있고, 특수문자가 들어갈 수도 있고, 번호만으로도 이루어질 수도 있고... 예상할 수 없게 된다.

## 3.1. 사용하는 식

*****

### 3.1.1. 입력(포인터 배운 후 수정 필요)

*****

```C
scanf("서식문자", 입력받을 내용의 주소값(포인터라고도 함));
```
이렇게 사용한다.

이렇게 사용할 수 있다.
>>> 포인터 배운 이후 다시 작성 에정

### 3.1.2. 출력

*****

```C
printf("서식문자", 출력한 내용의 주소값);
```

## 3.2. 코드 예시

*****

>>> 아직 포인터를 배우지 않았으므로 이해를 못할 것임.
>>> 포인터 배우고 나서 직접 예시를 만들어보자.

```C
#include "stdio.h"//C++에서의 입출력

int main()
{
    int num;//입력받아서 담아둘 변수

    scanf_s("%d", &num);//입력
    printf("%d", num);//출력
}
```

# 4. C++에서의 입출력

## 4.1. 사용하는 식

C++에서 입출력을 사용하기 위해서는 코드 맨 윗줄에 다음 식을 반드시 포함시켜야 한다.

```C++
#include <iostream>
using namespace std;
```

`#include <iostream>`은 입출력을 사용할 수 있게 해주는 헤더파일로, 이 헤더파일을 사용해야 `cin >>`과 `cout <<`를 사용할 수 있게 된다.

### 4.1.1. 입력과 출력

*****

출력은 '내보내다'라는 의미의 'out'를 포함한 `cout`, 입력은 '들여보내다'라는 의미의 'in'을 포함한 `cin`을 사용한다.

#### 4.1.1.1. 입력

*****

##### 4.1.1.1.1. 기본 사용법

*****

`cin`을 사용하기 위해서는 `>>`을 사용해야만 한다. 한 줄에 `>>`를 여러 번 사용함으로써 이스케이프 시퀸스를 사용하지 않고도 한 줄 안에서 줄바꿈 등을 할 수 있다.

```C++
cin >> 입력할 내용 또는 값을 대입할 변수;
```

##### 4.1.1.1.2. 예시

*****

다음은 입력 예시이다.

```C++

#include <iostream>
using namespace std;

int main()
{
	int a;

	cout << "출력할 수를 입력하세요: ";
	cin >> a;
	cout << endl << endl << a;

	return 0;
}
```

##### 4.1.1.1.3. 결과

*****

유저가 `출력할 수를 입력하세요: `에서 입력한 숫자를 출력할 것이다.

1을 입력했다면 1을 출력하고, 11을 입력했다면 11을 출력한다.



#### 4.1.1.2. 출력

*****

##### 4.1.1.2.1. 사용 방법

*****

`cout`을 사용하기 위해서는 `<<`를 사용해야 한다. 한 줄에 `<<`를 여러 번 사용함으로써 이스케이프 시퀸스를 사용하지 않고도 한 줄 안에서 줄바꿈 등을 할 수 있다.

```C++
cout << 출력할 내용;
```

##### 4.1.1.2.2. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	cout << "hello world";

	return 0;
}
```

##### 4.1.1.2.3. 결과

*****

```txt
hello world
```

# 5. 변수

*****

## 5.1. 변수란?

*****

> 1. 변할 수 있는 수
> 2. 데이터(data)를 저장할 수 있는 메모리 공간
> 3. 데이터를 저장하기 위해 프로그램에 의해서, 이름을 할당받은 메모리 공간

## 5.2. 변수의 구분

*****

### 5.2.1. 개요

*****

> 변수는 크게 **정수형 변수**와 **실수형 변수**로 구분된다.
> 이를 타입이라고 부른다. 자료형이라고도 부르며, 이하 문서에서는 **자료형**으로 표기한다.

### 5.2.2. 종류

*****

#### 5.2.2.1. 정수형

*****

+ char(캐릭터): 1byte signed 변수
+ int(integer): 1byte signed 변수

#### 5.2.2.2. 실수형

*****

+ float: 4byte signed 변수
+ double: 8byte signed 변수

## 5.3. 변수의 생성

*****

### 5.3.1. 변수의 선언

*****

```txt
자료형 변수명;
```

### 5.3.2. 예시

*****

```C++
int Number;
```

변수는 함수의 안에도, 밖에도 선언할 수 있다.

## 5.4. 변수명 

*****

### 5.4.1. 개요

*****

> 알아보기 쉽도록 간결하지만 어떤 용도인지 의미가 확실히 전달되도록 만들자.
> 표기법을 사용하는 것도 나쁘지 않은 방법이다.

## 5.5. 표기법

*****

### 5.5.1. 개요

*****

프로그래밍 용어로, 변수를 표기하는 방법을 의미한다.

대표적으로 **헝가리안법**과 **카멜법**이 있다.


### 5.5.2. 헝가리안법

*****

> 변수명 앞에 변수의 자료형을 뜻하는 문자를 붙여서 표시하는 법.

#### 5.5.2.1. 정수형

*****

변수명 앞에 `i` 또는 `n`을 붙여서 표현한다.

#### 5.5.2.2. 실수형

*****

변수명 앞에 `f`을 붙여서 표현한다.

#### 5.5.2.3. 문자열

*****

변수형 앞에 `sz`, 또는 `str`을 붙여서 표현한다.


## 5.6. 변수명 생성 규칙

*****

> <span style="color:red">\* 아래의 내용은 반드시 지켜져야만 한다.</span>

1. **변수 이름은 영어와 언더바(_)로만 구성한다.**
2. **숫자는 변수에서 가장 처음에 올 수 없다.**
    + 예시:
    `1Number` (X)
    `Number1` (O)
3. **공백을 넣을 수 없다.**
공백을 반드시 넣어야 한다면, 언더바(_)를 사용한다.
    + 예시:
    `Player Name` (X)
    `Player_Name` (O)
4. **변수명 길이에는 제한이 없다.**
5. **선언하고자 하는 변수의 타입(자료형)이 같다면, 한 번에 묶어서 복수의 변수를 선언할 수도 있다.**
    + 예시:
    `int a, float b;` (X)
    `int a, b;` (O)
6. **변수명에 예약어는 사용할 수 없다. 변수로 인식하지 않고 예약어로 인식한다.**
7. **선언과 동시에 초기화할 수 있다.**
여러 변수를 한 번에 복수 선언을 하는 경우에도 선언과 동시에 초기화를 하는 것이 가능하다.
    + 예시:
    `int a = 0;`(한 번에 **하나만 선언**하는 경우)
    + __예시:
    `int a, b = 0;`(한 번에 **여러 개를 복수 선언**하는 경우)

# 6. 상수

*****

## 6.1. 상수란?

*****

> 1. **변수와 똑같이 데이터를 저장할 수 있는 메모리 공간.**
> 2. **데이터를 저장하기 위해 프로그램에 의해서, 이름을(받을 수도 있고 받지 않을 수도 있다) 할당받은 메모리 공간.**
> 3. **수학적 개념; 1, 2, 3, 4, 5, ...**

## 6.2. 상수의 종류

*****

### 6.2.1. 리터럴 상수

*****

> 이름을 할당받지 않는 상수

### 6.2.2. 심볼릭 상수

*****

> 이름을 할당받는 상수

### 6.2.3. `define` 상수

*****

> 전역 상수

#### 6.2.3.1. 사용법

*****

```C++
#define 상수명 상수값;
```

위와 같은 형태로 사용한다.

define 문에는 `;`가 붙지 않는다.

`#define`을 통해 선언한 값은 함부로 바꾸려고 해서는 안된다. 바꾸기 위해서는 반드시 0으로 초기화한 다음 사용해야 한다.

#### 6.2.3.2. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
    #define NUMBER = 100

    NUMBER = 0;
    cin >> NUMBER;
    cout << NUMBER;

    return 0;
}
```

### 6.2.4. `const` 상수

*****

> 전역 상수
> 지역 상수
> 정적 상수



__리터럴 상수:__ 이름을 할당받지 않는 상수

__심볼릭 상수:__ 이름을 할당받는 상수

__define 상수, const 상수__

+ __define 상수:__ 전역 상수
+ __const 상수:__ 전역, 지역, 정적 상수

#### 6.2.4.1. 사용법

*****

```C++
const 자료형 상수명 = 상수
```



# 7. 캐스팅(형변환)

*****

## 7.1. 캐스팅(형변환)이란?

*****

> 자료형을 변환시키는 방법.

## 7.2. 주의할 점

*****

1. **자료형을 자동으로 변환해주지만, 자동으로 변환할 때 오류가 발생할 수도 있다.**
2. **함수와 연관해서 많이 사용한다.**
    + `숫자 --> 문자`는 가능하지만, `문자 --> 숫자`는 불가능하다.
    + `숫자 --> 숫자`는 가능하다.
    보통은 정수를 실수로, 실수를 정수로 바꿀 때 사용한다.
    + `문자 --> 문자`는 사용할 일이 없다.
    + `byte` 수를 알아야 한다.
        - `작은 byte --> 큰 byte`는 가능하다.
        - `큰 byte --> 작은 byte`는 가능하지만, 손실이 발생한다.

## 7.3. 사용법

*****

```txt
(변경할 자료형)변수형
```

## 7.4. 코드 예시

*****

만약 함수의 인자값으로 `float`형을 요구하는데, 보낼 인자값이 `int`인 경우 `int`형에서 `float`형으로 변환해서 인자값으로 보내주어야 한다.

```C++
#include <iostream>
using namespace std;

int main()
{
    float i = 4.5;
    i = (int)i;
    cout << i;

    return 0;
}
```

## 7.5. 결과

*****

```txt
4
```

만약 중간에 `i = (int)i;`를 통해 `float`형이었던 `i`를 `int`형으로 바꾸지 않았다면, 맨 처음 선언했던 실수인 '4.5'가 그대로 출력되었을 것이다.

하지만 중간에 `int`형으로 바꾸어주었기 때문에 소수점이 삭제되었다. 따라서 출력된 수는 '4' 이다.

# 8. 연산자

*****

## 8.1. 연산자의 종류

*****

### 8.1.1. 산술연산자

*****

> 일반적인 산술(더하기, 빼기, 나누기, 곱하기 등)을 표현하기 위한 연산자들.

#### 8.1.1.1. `+`

*****

>더하기

왼쪽의 피연산자에 오른쪽의 피연산자를 더한다.

##### 8.1.1.1.1. 예시

*****

```C++
int main()
{
    int a;
    int b;

    b = a + 1;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.1.2. 결과

*****

```txt
유저가 입력한 수 + 1
```

#### 8.1.1.2. `-`

*****

> 빼기

왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀다.

##### 8.1.1.2.1. 예시

*****

a에서 2 빼기

```C++
int main()
{
    int a;
    int b;

    b = a - 2;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.2.2. 결과

*****

```txt
유저가 입력한 수 - 2
```

#### 8.1.1.3. `*`

*****

> 곱하기

왼쪽의 피연산자에 오른쪽의 피연산자를 곱한다.

##### 8.1.1.3.1. 예시

*****

a에 3을 곱함

```C++
int main()
{
    int a;
    int b;

    b = a * 3;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.3.2. 결과

*****

```txt
유저가 입력한 수 X 3
```

#### 8.1.1.4. `/`

*****

> 나누기

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈다.

##### 8.1.1.4.1. 예시

*****

a를 3으로 나눔

```C++
int main()
{
    int a;
    int b;

    b = a / 3;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.4.2. 결과

*****

```txt
유저가 입력한 수를 3으로 나눈 수
```

#### 8.1.1.5. `%`

*****

> 나머지

왼쪽의 피연산자를 오른쪽의 피연산자로 나누고, 나머지를 반환한다.

#### 8.1.1.5.1. 예시

*****

a를 3으로 나눈 나머지

```C++
int main()
{
    int a;
    int b;

    b = a % 3;

    cin >> a;
    cout << b;

    return 0;
}
```

#### 8.1.1.5.2. 결과

*****

```txt
유저가 입력한 수를 3으로 나눴을 때의 나머지
```

### 8.1.2. 증감연산자

*****

> 단순히 1을 더하거나, 뺄 때 사용하는 연산자

C++에서 추가된 연산자로, 기호를 두 번 붙이는 것만으로도 등식을 사용할 수 있다.

#### 8.1.2.1. 형태

*****

`++?`, `?++`의 형태로 사용할 수 있다. 여기에서 주의할 점은, 두 형태의 의미가 서로 다르다는 것이다.

각각의 사용법은 다음과 같다.

##### 8.1.2.1.1. `?++`

*****

```txt
?++ = ? + 1
```

##### 8.1.2.1.2. `++?`

*****

```txt
++? = (? + 1)
```

#### 8.1.2.2. 종류

*****

큰 형태와 의미는 `?++`와 `?--`가 비슷하고, `++?`와 `--?`가 비슷하기 때문에, `?++`, `?--`에 대해서만 작성한다.

##### 8.1.2.2.1. `a++`,

*****

> 더하기

`a + 1`과 같은 용도이다.

###### 8.1.2.2.1.1. 예시

*****

```C++
int main()
{
    cout << 1++;

    return 0;
}
```

###### 8.1.2.2.1.2. 결과

*****

```txt
2
```

##### 8.1.2.2.2. `--`

*****

> 빼기

`a - 1`과 같은 용도이다.

###### 8.1.2.2.2.1. 예시

*****

```C++
int main()
{
    cout << 3--;

    return 0;
}
```

###### 8.1.2.2.2.2. 결과

*****

```txt
2
```

### 8.1.3. 논리연산자

*****

#### 8.1.3.1. `&&`

*****

`그리고`라는 뜻이다.

논리식이 모두 참이면 참을 반환한다.

##### 8.1.3.1.1. 예시

*****

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << endl;
        cout << i + 1 << "번째 번호: ";
        cin >> tagWand[i];
        cout << endl << endl;
    }
    if (tagWand[i] == 1 && tagWand[i] == 3)
    {
        cout << "축하합니다! 번호를 모두 맞추셨습니다!";
    }
    else
    {
        cout << "번호를 맞추지 못했습니다.";
    }   

    return 0;
}
```

##### 8.1.3.1.2. 결과

*****

> 1, 2를 차례대로 모두 쓴 경우

```txt
숫자를 모두 쓰셨습니다.
```

> 순서를 하나라도 맞추지 못한 경우

```txt
번호를 맞추지 못했습니다.
```

#### 8.1.3.2. `||`

*****

> 그리고

논리식 중에서 하나라도 참이면 참을 반환한다.

##### 8.1.3.2.1. 예시

*****

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << i + 1 << "번째 번호 선택: ";
        cin >> tagWand[i];
        cout << endl;
    }
    if (tagWand[i] == 1 || tagWand[i] == 3)
    {
        cout << "축하합니다! 맞춘 번호가 있습니다!" << endl;
    }
    else if (tagWand[i] != 1 && tagwand[i] != 3)
    {
        cout << "맞춘 번호가 하나도 없습니다." << endl;
    }    

    return 0;
}
```

##### 8.1.3.2.2. 결과

*****

> 맞춘 번호가 하나라도 있는 경우

```txt
축하합니다! 맞춘 번호가 있습니다!
```

> 맞춘 번호가 하나도 없는 경우

```txt
맞춘 번호가 하나도 없습니다.
```

#### 8.1.3.3. `!`

*****

> 아니다

논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환한다.

##### 8.1.3.3.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
    int a = 0;
    cin >> a;
    if (a != 1)
    {
        cout << "1이 아닙니다." << endl;
    }

    return 0;
}
```

##### 8.1.3.3.2. 결과

*****

> a가 1이 아닌 경우

```txt
1이 아닙니다.
```

### 8.1.4. 대입연산자

*****

#### 8.1.4.1. `=`

*****

왼쪽의 피연산자에 오른쪽의 피연산자를 대입한다.

##### 8.1.4.1.1. 예시

*****

```C++
int main()
{
    int a = 0;

    a = 1;

    cout << a;

    return 0;
}
```

##### 8.1.4.1.2. 결과

*****

```txt
1
```

#### 8.1.4.2. `+=`

*****

왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.2.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a += 2;
	cout << a;

	return 0;
}
```

##### 8.1.4.2.2. 결과

*****

```txt
3
```

#### 8.1.4.3. `-=`

*****

왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.3.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a -= 2;
	cout << a;

	return 0;
}
```

##### 8.1.4.3.2. 결과

*****

```txt
-1
```

#### 8.1.4.4. `/=`

*****

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.4.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a /= 3;

	cout << b;

	return 0;
}
```

##### 8.1.4.4.2. 결과

*****

```txt
3
```

#### 8.1.4.5. `%=`

*****

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.5.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a %= 3;

	cout << b;

	return 0;
}
```

##### 8.1.4.5.2. 결과

*****

```txt
0
```

### 8.1.5. 비교연산자

*****

우리가 수학에서 확인할 수 있는 일반적인 부등호의 그것과 같다.

다만, `크거나 같다(이상)`, `작거나 같다(이하)`의 경우에는 수학 기호와 표기법이 약간 다르다.

#### 8.1.5.1. `>`

*****

왼쪽에 있는 값이 오른쪽보다 크다는 의미이다.

#### 8.1.5.2. `<`

*****

왼쪽에 있는 값이 오른쪽보다 작다는 의미이다.

#### 8.1.5.3. `<=`

*****

왼쪽에 있는 값이 오른쪽보다 작거나 같다는 의미이다.

#### 8.1.5.4. `>=`

*****

왼쪽에 있는 값이 오른쪽보다 크거나 같다는 의미이다.

# 9. 제어문

*****

제어문을 사용하는 이유는 **내가 원하는 결과를 얻기 위해서** 이다.

프로그램의 순차적인 흐름을 제어해야 하는 경우가 생긴다. 이럴 때 사용하는 명령문을 **제어문** 이라고 한다.

## 9.0. 제어문의 구성

*****

+ 조건문
  - `if`
    * `if / else`
    * `if / else if`
  - `switch`
+ 반복문
  - `for`
  - `while`
  - `do ~ while`

## 9.1. 조건문

*****

### 9.1.1. 조건문 `if`

*****

#### 9.1.1.1. 예시

*****

```C++
if (조건식)
{
    조건식이 참일 때 실행할 내용
    (아니면 실행 X)
}
else if (조건식)
{
    if의 조건문이 거짓이고,
    else if의 조건문이 참일때 실행할 내용
    (아니면 실행 X)
}
else if (조건식)
{
    if, 첫번째 else if의 조건문이 거짓이고
    해당 else if의 조건문이 참일때 실행할 내용
}
else
{
    위의 모든 조건식이 거짓일 때 실행할 내용
}
```

#### 9.1.1.2. 해설

*****

컴퓨터의 해석 과정은 다음과 같이 진행된다.

1. if 조건식이 참인가?
    + **예:**
    실행할 내용을 실행한다. else if 또는 else의 내용과 조건문은 검토하거나 실행하지 않고 건너뛴다.
    + **아니요:**
    else if 조건식을 확인한다.
2. else if 조건식이 참인가?
    + **예:**
    실행할 내용을 실행한다. 하단에 남아있는 else if 또는 else의 내용과 조건문은 검토하거나 실행하지 않고 건너뛴다.
    + **아니요:**
    다음 else if 또는 else를 확인한다.
3. if 또는 else if 중 참인 조건식이 없는 경우
    + else의 실행할 내용을 실행한다.

### 9.1.2. 조건문 `switch`

*****

주어진 값의 결과에 따라서 다른 명령을 수행하도록 하는 명령문이다.

#### 9.1.2.1. `switch`문의 구성

*****

```C++
switch (/*변수*/)
{
    case /*변수값*/:
    /*실행할 내용*/
    break;

    case /*변수값*/:
    /*실행할 내용*/
    break;

    default
    /*실행할 내용*/
    break;
}
```

##### 9.1.2.1.1. `default`

*****

+ `switch`문에 나열되어 있는 모든 `case`에 해당하지 않을 때 여기부터 실행한다.
+ `default`의 위치는 반드시 맨 아래가 아니여도 된다.
+ 구문상 반드시 포함해야 하는 것도 아니다.

##### 9.1.2.1.2. `break`

*****

+ `switch`문의 종료 명령어.
+ `break`가 존재하지 않을 경우 이하 모든 case에 대해 실행한다.

int보다 작은 byte의 변수 `char`, `short`, 열거문(`enum`)과 같은 것들도 조건으로 사용할 수 있다.

`int`, `short`, 열거문(`enum`)의 경우에는 숫자로, `char`의 경우에는 문자로 판단한다.

#### 9.1.2.2. `if`와의 차이점

*****

1. 처리속도가 빠르다.
2. 디테일한 조정이 불가능하다.(string 변수 사용 불가능)

## 9.2. 반복문

*****

### 9.2.1. 반복문 `while`

*****






















### 사용법_반복문 `while`

```C++
while (/*조건식*/)
{
    /*조건이 true일 때 반복 실행할 내용*/
}
```
<span style = "color:red">
* 주의할 점:

반복 실행할 내용에 증감식을 적어두어야 한다.

</span>

## 반복문 `do~while`

### 사용법_반복문 `do~while`

```C++
do
{
    /*
    조건식이 true일때 이 안의 내용을 반복 실행한다.
    조건식의 결과를 변경해줄 내용이다.
    */
}while (조건식)
```

### `while`과의 차이점

조건식의 위치.
`while`은 조건식이 참일 때 실행할 내용 위에 있고, `do ~ while`은 조건이 참일 때 실행할 내용의 밑에 있다.
따라서 `do ~ while`을 하게 되면 true/false에 상관 없이 무조건 1번은 실행하게 된다.

## 반복문 `for`

while처럼 조건식이 상단에 있는 반복문이다. 따라서, while처럼 내용을 실행하기 전 먼저 true / false를 판단한다.

기본 문법 하나에 초기식, 조건식, 증감식을 전부 포함하기 때문에 오류가 날 가능성이 적다.

그러한 이유로, while보다 간결하게, 보기 쉽게 표현할 수 있다.

### 사용법_반복문 `for`

```C++
#include <iostream>
using namespace std;

int main()
{
	int i;

	for (i = 0; i < 10; i++)
	{
		cout << i + 1 << endl;
	}

	return 0;
}
```

결과:

```txt
1
2
3
4
5
6
7
8
9
10
```

+ __증감식의 조건__: `while`과 동일하게 조건식을 종료할 수 있는, 혹은 영향을 줄 수 있는 식이어야 한다.

*****

# 배열

+ 같은 자료형의 변수의 집합이다.
+ 같은 자료형의 데이터를 많이 다뤄야 하는 경우에 사용한다.

## 배열 선언 방법
`자료형 배열명[배열길이];`를 입력해서 선언할 수 있다.



## 배열명 생성

["IV. 변수"의 변수명 생성 규칙과 동일하다.](#변수명-생성-규칙)


C++에서의 인덱스(넘버링는 0부터 시작한다.

+ __배열 길이가 10일때:__ `[0] ~ [9]`, 총 10개의 배열이 생성된다.
+ __배열 번호라 부르는 0 ~ 9:__ 인덱스(index)
+ __엘리멘트(요소, element):__ 인덱스의 배열명을 포함한 값

```C++
number[0]
number[1]
//...
number[9]
```

## 배열의 길이

배열의 길이는 해당 배열이 몇 개의 배열 요소를 가질지를 명시한다.

배열이 선언된 상태에서 배열명(ex --> `Number`)은 포인터로도 사용된다.

## 배열의 초기화

> 1. 배열은 선언과 동시에 초기화를 해주는 것이 좋다.
> 배열은 집합이기 때문에 초기화를 여러 개를 해주어야 한다.

> __중괄호__ 와 __쉼표__ 를 이용해서 인덱스의 구분을 통한 초기화를 진행한다.
> 인덱스의 길이가 길어지면 반복문을 통한 초기화를 하는 것이 좋다.

```C++
int Number[i];
int i;

for (i = 0; i < 1000; i++)
{
    Number[i] = 0;
}
```

## 배열의 특징

> 배열은 선언과 동시에 초기화해야 한다.

```C++
int Number[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; //(O)

int Number[10];
Number[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; //(X)
```
2. 길이가 같더라도 배열에서 배열로 대입은 불가능하다.

```C++
int a[5] - {1, 2, 3, 4, 5};
int b[5];

b = a; //(X)

int i;

for(i = 0; i < 5; i++)
{
    b[i] = a[i]; //(O)
}
```

3. 배열 길이는 반드시 상수여야 한다.(변수 X)
    + 변수를 넣는 것은 후에 '동적 할당'이라는 것을 배운 이후부터 할 것
4. 배열 길이를 입력하지 않고, 초기화하는 값의 개수에 따라 배열 길이가 자동으로 할당된다.

# 배열의 특징