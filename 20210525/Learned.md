# 목차

***

<details>
<summary>터치해서 목차 펼치기</summary>

- [목차](#목차)
- [1. 입출력](#1-입출력)
  - [1.1. 입출력을 사용하기 위한 입출력 헤더파일](#11-입출력을-사용하기-위한-입출력-헤더파일)
    - [1.1.1. C](#111-c)
      - [1.1.1.1. 사용법](#1111-사용법)
    - [1.1.2. C++](#112-c)
      - [1.1.2.1. 사용법](#1121-사용법)
- [2. C와 C++에서 모두 사용하는 것들](#2-c와-c에서-모두-사용하는-것들)
  - [2.1. 이스케이프 시퀸스](#21-이스케이프-시퀸스)
    - [2.1.1. 이스케이프 시퀸스란?](#211-이스케이프-시퀸스란)
    - [2.1.2. \t](#212-t)
    - [2.1.3. \n](#213-n)
  - [2.2. 서식문자(서식 지정자)](#22-서식문자서식-지정자)
    - [2.2.1. 형태](#221-형태)
    - [2.2.2. 자주 사용되는 서식문자](#222-자주-사용되는-서식문자)
      - [2.2.2.1. d, i](#2221-d-i)
      - [2.2.2.2. s](#2222-s)
      - [2.2.2.3. f](#2223-f)
- [3. C에서의 입출력](#3-c에서의-입출력)
  - [3.1. 사용하는 식](#31-사용하는-식)
    - [3.1.1. 입력(포인터 배운 후 수정 필요)](#311-입력포인터-배운-후-수정-필요)
    - [3.1.2. 출력](#312-출력)
  - [3.2. 코드 예시](#32-코드-예시)
- [4. C++에서의 입출력](#4-c에서의-입출력)
  - [4.1. 사용하는 식](#41-사용하는-식)
    - [4.1.1. 입력과 출력](#411-입력과-출력)
      - [4.1.1.1. 입력](#4111-입력)
        - [4.1.1.1.1. 기본 사용법](#41111-기본-사용법)
        - [4.1.1.1.2. 예시](#41112-예시)
        - [4.1.1.1.3. 결과](#41113-결과)
      - [4.1.1.2. 출력](#4112-출력)
        - [4.1.1.2.1. 사용 방법](#41121-사용-방법)
        - [4.1.1.2.2. 예시](#41122-예시)
        - [4.1.1.2.3. 결과](#41123-결과)
- [5. 변수](#5-변수)
  - [5.1. 변수란?](#51-변수란)
  - [5.2. 변수의 구분](#52-변수의-구분)
    - [5.2.1. 개요](#521-개요)
    - [5.2.2. 종류](#522-종류)
      - [5.2.2.1. 정수형](#5221-정수형)
      - [5.2.2.2. 실수형](#5222-실수형)
  - [5.3. 변수의 생성](#53-변수의-생성)
    - [5.3.1. 변수의 선언](#531-변수의-선언)
    - [5.3.2. 예시](#532-예시)
  - [5.4. 변수명](#54-변수명)
    - [5.4.1. 개요](#541-개요)
  - [5.5. 표기법](#55-표기법)
    - [5.5.1. 개요](#551-개요)
    - [5.5.2. 헝가리안법](#552-헝가리안법)
      - [5.5.2.1. 정수형](#5521-정수형)
      - [5.5.2.2. 실수형](#5522-실수형)
      - [5.5.2.3. 문자열](#5523-문자열)
  - [5.6. 변수명 생성 규칙](#56-변수명-생성-규칙)
- [6. 상수](#6-상수)
  - [6.1. 상수란?](#61-상수란)
  - [6.2. 상수의 종류](#62-상수의-종류)
    - [6.2.1. 리터럴 상수](#621-리터럴-상수)
    - [6.2.2. 심볼릭 상수](#622-심볼릭-상수)
    - [6.2.3. `define` 상수](#623-define-상수)
      - [6.2.3.1. 사용법](#6231-사용법)
      - [6.2.3.2. 예시](#6232-예시)
    - [6.2.4. `const` 상수](#624-const-상수)
      - [6.2.4.1. 사용법](#6241-사용법)
- [7. 캐스팅(형변환)](#7-캐스팅형변환)
  - [7.1. 캐스팅(형변환)이란?](#71-캐스팅형변환이란)
  - [7.2. 주의할 점](#72-주의할-점)
  - [7.3. 사용법](#73-사용법)
  - [7.4. 코드 예시](#74-코드-예시)
  - [7.5. 결과](#75-결과)
- [8. 연산자](#8-연산자)
  - [8.1. 연산자의 종류](#81-연산자의-종류)
    - [8.1.1. 산술연산자](#811-산술연산자)
      - [8.1.1.1. `+`](#8111-)
        - [8.1.1.1.1. 예시](#81111-예시)
        - [8.1.1.1.2. 결과](#81112-결과)
      - [8.1.1.2. `-`](#8112--)
        - [8.1.1.2.1. 예시](#81121-예시)
        - [8.1.1.2.2. 결과](#81122-결과)
      - [8.1.1.3. `*`](#8113-)
        - [8.1.1.3.1. 예시](#81131-예시)
        - [8.1.1.3.2. 결과](#81132-결과)
      - [8.1.1.4. `/`](#8114-)
        - [8.1.1.4.1. 예시](#81141-예시)
        - [8.1.1.4.2. 결과](#81142-결과)
      - [8.1.1.5. `%`](#8115-)
      - [8.1.1.5.1. 예시](#81151-예시)
      - [8.1.1.5.2. 결과](#81152-결과)
    - [8.1.2. 증감연산자](#812-증감연산자)
      - [8.1.2.1. 형태](#8121-형태)
        - [8.1.2.1.1. `?++`](#81211-)
        - [8.1.2.1.2. `++?`](#81212-)
      - [8.1.2.2. 종류](#8122-종류)
        - [8.1.2.2.1. `a++`,](#81221-a)
          - [8.1.2.2.1.1. 예시](#812211-예시)
          - [8.1.2.2.1.2. 결과](#812212-결과)
        - [8.1.2.2.2. `--`](#81222---)
          - [8.1.2.2.2.1. 예시](#812221-예시)
          - [8.1.2.2.2.2. 결과](#812222-결과)
    - [8.1.3. 논리연산자](#813-논리연산자)
      - [8.1.3.1. `&&`](#8131-)
        - [8.1.3.1.1. 예시](#81311-예시)
        - [8.1.3.1.2. 결과](#81312-결과)
      - [8.1.3.2. `||`](#8132-)
        - [8.1.3.2.1. 예시](#81321-예시)
        - [8.1.3.2.2. 결과](#81322-결과)
      - [8.1.3.3. `!`](#8133-)
        - [8.1.3.3.1. 예시](#81331-예시)
        - [8.1.3.3.2. 결과](#81332-결과)
    - [8.1.4. 대입연산자](#814-대입연산자)
      - [8.1.4.1. `=`](#8141-)
        - [8.1.4.1.1. 예시](#81411-예시)
        - [8.1.4.1.2. 결과](#81412-결과)
      - [8.1.4.2. `+=`](#8142-)
        - [8.1.4.2.1. 예시](#81421-예시)
        - [8.1.4.2.2. 결과](#81422-결과)
      - [8.1.4.3. `-=`](#8143--)
        - [8.1.4.3.1. 예시](#81431-예시)
        - [8.1.4.3.2. 결과](#81432-결과)
      - [8.1.4.4. `/=`](#8144-)
        - [8.1.4.4.1. 예시](#81441-예시)
        - [8.1.4.4.2. 결과](#81442-결과)
      - [8.1.4.5. `%=`](#8145-)
        - [8.1.4.5.1. 예시](#81451-예시)
        - [8.1.4.5.2. 결과](#81452-결과)
    - [8.1.5. 비교연산자](#815-비교연산자)
      - [8.1.5.1. `>`](#8151-)
      - [8.1.5.2. `<`](#8152-)
      - [8.1.5.3. `<=`](#8153-)
      - [8.1.5.4. `>=`](#8154-)
    - [8.1.6. 비트연산자](#816-비트연산자)
      - [8.1.6.1. `&`](#8161-)
      - [8.1.6.2. `|`](#8162-)
      - [8.1.6.3. `^`](#8163-)
      - [8.1.6.4. `~`](#8164-)
      - [8.1.6.5. `?`](#8165-)
        - [8.1.6.5.1. 사용법](#81651-사용법)
        - [8.1.6.5.2. 예시](#81652-예시)
      - [8.1.6.6. `,`](#8166-)
      - [8.1.6.7. `sizeof`](#8167-sizeof)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>
</details>
<br>
<br>

***

# 1. 입출력

*****

## 1.1. 입출력을 사용하기 위한 입출력 헤더파일

*****

### 1.1.1. C

*****

`stdio.h` __:__ 인클루드(포함)

#### 1.1.1.1. 사용법

*****

```C
#include "stdio.h"
```

### 1.1.2. C++

*****

`iostream.h` __:__ 인클루드

#### 1.1.2.1. 사용법

*****

```C++
#include <iostream>
```

# 2. C와 C++에서 모두 사용하는 것들

*****

## 2.1. 이스케이프 시퀸스

*****

### 2.1.1. 이스케이프 시퀸스란?

*****

> `\?` 형태로 큰따옴표 안에 들어가는 예약어로, 대표적인 이스케이프 시퀸스로는
> `\t`, `\n`, `\v` 등이 있다.

### 2.1.2. \t

*****

"Tab"을 사용해주는 이스케이프 시퀸스이다.

```C++
#include <iostream>
using namespace std;

int main()
{
    cout << "이스케이프\t시퀸스";
    
    return 0;
}
```

사용하면 다음과 같이 출력된다.

```txt
이스케이프  시퀸스
```

### 2.1.3. \n

*****

줄바꿈 기능을 위해 사용하는 이스케이프 시퀸스이다.

Cpp에서는 보통 `endl`을 더욱 많이 사용한다.

```C++
#include <iostream>
using namespace std;

int main()
{
    cout << "이스케이프\n시퀸스";

    return 0;
}
```

출력 결과는 다음과 같다.

```txt
이스케이프
시퀸스
```

## 2.2. 서식문자(서식 지정자)

*****

### 2.2.1. 형태

*****

`%?`의 형태로 출력한다. `?` 부분에 서식문자를 구분하는 알파벳이 들어간다.

### 2.2.2. 자주 사용되는 서식문자

*****

#### 2.2.2.1. d, i

*****

십진수형 정수를 출력할 때에 사용한다.

`d`와 `i`는 동일한 위치에 사용된다.

```C
#include "stdio.h"

int main()
{
	printf("%d", 1);

	return 0;
}
```

다음은 결과이다.

```txt
1
```

#### 2.2.2.2. s

*****

문자열을 출력할 때에 사용한다.

```C
#include "stdio.h"

int main()
{
	printf("%s", "hello world");

	return 0;
}
```

다음은 결과이다.

```txt
hello world
```

#### 2.2.2.3. f

*****

십진수형 실수를 출력할 때 사용한다.

```C
#include "stdio.h"

int main()
{
	printf("%f", 1.45);

	return 0;
}
```

다음은 결과이다.

```txt
1.450000
```


# 3. C에서의 입출력

*****

출력은 안에 이미 값이 있기 때문에 얼마만큼을(크기) 출력하면 되는가에 대해서 미리 알 수 있다. 따라서 출력만 하는 것은 그렇게 어렵지 않다.

하지만 입력이 함께 사용되는 경우 난이도가 올라간다.

아이디를 만든다고 가정해보자. 수십, 수백명의 유저가 각자가 원하는 아이디를 만들 것이다. 심지어 그 아이디는 번호가 들어갈 수도 있고, 특수문자가 들어갈 수도 있고, 번호만으로도 이루어질 수도 있고... 예상할 수 없게 된다.

## 3.1. 사용하는 식

*****

### 3.1.1. 입력(포인터 배운 후 수정 필요)

*****

```C
scanf("서식문자", 입력받을 내용의 주소값(포인터라고도 함));
```
이렇게 사용한다.

이렇게 사용할 수 있다.
>>> 포인터 배운 이후 다시 작성 에정

### 3.1.2. 출력

*****

```C
  ("서식문자", 출력한 내용의 주소값);
```

## 3.2. 코드 예시

*****

>>> 아직 포인터를 배우지 않았으므로 이해를 못할 것임.
>>> 포인터 배우고 나서 직접 예시를 만들어보자.

```C
#include "stdio.h"//C++에서의 입출력

int main()
{
    int num;//입력받아서 담아둘 변수

    scanf_s("%d", &num);//입력
    printf("%d", num);//출력
}
```

# 4. C++에서의 입출력

## 4.1. 사용하는 식

C++에서 입출력을 사용하기 위해서는 코드 맨 윗줄에 다음 식을 반드시 포함시켜야 한다.

```C++
#include <iostream>
using namespace std;
```

`#include <iostream>`은 입출력을 사용할 수 있게 해주는 헤더파일로, 이 헤더파일을 사용해야 `cin >>`과 `cout <<`를 사용할 수 있게 된다.

### 4.1.1. 입력과 출력

*****

출력은 '내보내다'라는 의미의 'out'를 포함한 `cout`, 입력은 '들여보내다'라는 의미의 'in'을 포함한 `cin`을 사용한다.

#### 4.1.1.1. 입력

*****

##### 4.1.1.1.1. 기본 사용법

*****

`cin`을 사용하기 위해서는 `>>`을 사용해야만 한다. 한 줄에 `>>`를 여러 번 사용함으로써 이스케이프 시퀸스를 사용하지 않고도 한 줄 안에서 줄바꿈 등을 할 수 있다.

```C++
cin >> 입력할 내용 또는 값을 대입할 변수;
```

##### 4.1.1.1.2. 예시

*****

다음은 입력 예시이다.

```C++

#include <iostream>
using namespace std;

int main()
{
	int a;

	cout << "출력할 수를 입력하세요: ";
	cin >> a;
	cout << endl << endl << a;

	return 0;
}
```

##### 4.1.1.1.3. 결과

*****

유저가 `출력할 수를 입력하세요: `에서 입력한 숫자를 출력할 것이다.

1을 입력했다면 1을 출력하고, 11을 입력했다면 11을 출력한다.



#### 4.1.1.2. 출력

*****

##### 4.1.1.2.1. 사용 방법

*****

`cout`을 사용하기 위해서는 `<<`를 사용해야 한다. 한 줄에 `<<`를 여러 번 사용함으로써 이스케이프 시퀸스를 사용하지 않고도 한 줄 안에서 줄바꿈 등을 할 수 있다.

```C++
cout << 출력할 내용;
```

##### 4.1.1.2.2. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	cout << "hello world";

	return 0;
}
```

##### 4.1.1.2.3. 결과

*****

```txt
hello world
```

# 5. 변수

*****

## 5.1. 변수란?

*****

> 1. 변할 수 있는 수
> 2. 데이터(data)를 저장할 수 있는 메모리 공간
> 3. 데이터를 저장하기 위해 프로그램에 의해서, 이름을 할당받은 메모리 공간

## 5.2. 변수의 구분

*****

### 5.2.1. 개요

*****

> 변수는 크게 **정수형 변수**와 **실수형 변수**로 구분된다.
> 이를 타입이라고 부른다. 자료형이라고도 부르며, 이하 문서에서는 **자료형**으로 표기한다.

### 5.2.2. 종류

*****

#### 5.2.2.1. 정수형

*****

+ char(캐릭터): 1byte signed 변수
+ int(integer): 1byte signed 변수

#### 5.2.2.2. 실수형

*****

+ float: 4byte signed 변수
+ double: 8byte signed 변수

## 5.3. 변수의 생성

*****

### 5.3.1. 변수의 선언

*****

```txt
자료형 변수명;
```

### 5.3.2. 예시

*****

```C++
int Number;
```

변수는 함수의 안에도, 밖에도 선언할 수 있다.

## 5.4. 변수명 

*****

### 5.4.1. 개요

*****

> 알아보기 쉽도록 간결하지만 어떤 용도인지 의미가 확실히 전달되도록 만들자.
> 표기법을 사용하는 것도 나쁘지 않은 방법이다.

## 5.5. 표기법

*****

### 5.5.1. 개요

*****

프로그래밍 용어로, 변수를 표기하는 방법을 의미한다.

대표적으로 **헝가리안법**과 **카멜법**이 있다.


### 5.5.2. 헝가리안법

*****

> 변수명 앞에 변수의 자료형을 뜻하는 문자를 붙여서 표시하는 법.

#### 5.5.2.1. 정수형

*****

변수명 앞에 `i` 또는 `n`을 붙여서 표현한다.

#### 5.5.2.2. 실수형

*****

변수명 앞에 `f`을 붙여서 표현한다.

#### 5.5.2.3. 문자열

*****

변수형 앞에 `sz`, 또는 `str`을 붙여서 표현한다.


## 5.6. 변수명 생성 규칙

*****

> <span style="color:red">\* 아래의 내용은 반드시 지켜져야만 한다.</span>

1. **변수 이름은 영어와 언더바(_)로만 구성한다.**
2. **숫자는 변수에서 가장 처음에 올 수 없다.**
    + 예시:
    `1Number` (X)
    `Number1` (O)
3. **공백을 넣을 수 없다.**
공백을 반드시 넣어야 한다면, 언더바(_)를 사용한다.
    + 예시:
    `Player Name` (X)
    `Player_Name` (O)
4. **변수명 길이에는 제한이 없다.**
5. **선언하고자 하는 변수의 타입(자료형)이 같다면, 한 번에 묶어서 복수의 변수를 선언할 수도 있다.**
    + 예시:
    `int a, float b;` (X)
    `int a, b;` (O)
6. **변수명에 예약어는 사용할 수 없다. 변수로 인식하지 않고 예약어로 인식한다.**
7. **선언과 동시에 초기화할 수 있다.**
여러 변수를 한 번에 복수 선언을 하는 경우에도 선언과 동시에 초기화를 하는 것이 가능하다.
    + 예시:
    `int a = 0;`(한 번에 **하나만 선언**하는 경우)
    + __예시:
    `int a, b = 0;`(한 번에 **여러 개를 복수 선언**하는 경우)

# 6. 상수

*****

## 6.1. 상수란?

*****

> 1. **변수와 똑같이 데이터를 저장할 수 있는 메모리 공간.**
> 2. **데이터를 저장하기 위해 프로그램에 의해서, 이름을(받을 수도 있고 받지 않을 수도 있다) 할당받은 메모리 공간.**
> 3. **수학적 개념; 1, 2, 3, 4, 5, ...**

## 6.2. 상수의 종류

*****

### 6.2.1. 리터럴 상수

*****

> 이름을 할당받지 않는 상수

### 6.2.2. 심볼릭 상수

*****

> 이름을 할당받는 상수

### 6.2.3. `define` 상수

*****

> 전역 상수

#### 6.2.3.1. 사용법

*****

```C++
#define 상수명 상수값
```

위와 같은 형태로 사용한다.

define 문에는 `;`가 붙지 않는다.

`#define`을 통해 선언한 값은 함부로 바꾸려고 해서는 안된다. 바꾸기 위해서는 반드시 0으로 초기화한 다음 사용해야 한다.

#### 6.2.3.2. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
    #define NUMBER = 100

    NUMBER = 0;
    cin >> NUMBER;
    cout << NUMBER;

    return 0;
}
```

### 6.2.4. `const` 상수

*****

> 전역 상수
> 지역 상수
> 정적 상수



__리터럴 상수:__ 이름을 할당받지 않는 상수

__심볼릭 상수:__ 이름을 할당받는 상수

__define 상수, const 상수__

+ __define 상수:__ 전역 상수
+ __const 상수:__ 전역, 지역, 정적 상수

#### 6.2.4.1. 사용법

*****

```C++
const 자료형 상수명 = 상수
```



# 7. 캐스팅(형변환)

*****

## 7.1. 캐스팅(형변환)이란?

*****

> 자료형을 변환시키는 방법.

## 7.2. 주의할 점

*****

1. **자료형을 자동으로 변환해주지만, 자동으로 변환할 때 오류가 발생할 수도 있다.**
2. **함수와 연관해서 많이 사용한다.**
    + `숫자 --> 문자`는 가능하지만, `문자 --> 숫자`는 불가능하다.
    + `숫자 --> 숫자`는 가능하다.
    보통은 정수를 실수로, 실수를 정수로 바꿀 때 사용한다.
    + `문자 --> 문자`는 사용할 일이 없다.
    + `byte` 수를 알아야 한다.
        - `작은 byte --> 큰 byte`는 가능하다.
        - `큰 byte --> 작은 byte`는 가능하지만, 손실이 발생한다.

## 7.3. 사용법

*****

```txt
(변경할 자료형)변수형
```

## 7.4. 코드 예시

*****

만약 함수의 인자값으로 `float`형을 요구하는데, 보낼 인자값이 `int`인 경우 `int`형에서 `float`형으로 변환해서 인자값으로 보내주어야 한다.

```C++
#include <iostream>
using namespace std;

int main()
{
    float i = 4.5;
    i = (int)i;
    cout << i;

    return 0;
}
```

## 7.5. 결과

*****

```txt
4
```

만약 중간에 `i = (int)i;`를 통해 `float`형이었던 `i`를 `int`형으로 바꾸지 않았다면, 맨 처음 선언했던 실수인 '4.5'가 그대로 출력되었을 것이다.

하지만 중간에 `int`형으로 바꾸어주었기 때문에 소수점이 삭제되었다. 따라서 출력된 수는 '4' 이다.

# 8. 연산자

*****

## 8.1. 연산자의 종류

*****

### 8.1.1. 산술연산자

*****

> 일반적인 산술(더하기, 빼기, 나누기, 곱하기 등)을 표현하기 위한 연산자들.

#### 8.1.1.1. `+`

*****

>더하기

왼쪽의 피연산자에 오른쪽의 피연산자를 더한다.

##### 8.1.1.1.1. 예시

*****

```C++
int main()
{
    int a;
    int b;

    b = a + 1;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.1.2. 결과

*****

```txt
유저가 입력한 수 + 1
```

#### 8.1.1.2. `-`

*****

> 빼기

왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀다.

##### 8.1.1.2.1. 예시

*****

a에서 2 빼기

```C++
int main()
{
    int a;
    int b;

    b = a - 2;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.2.2. 결과

*****

```txt
유저가 입력한 수 - 2
```

#### 8.1.1.3. `*`

*****

> 곱하기

왼쪽의 피연산자에 오른쪽의 피연산자를 곱한다.

##### 8.1.1.3.1. 예시

*****

a에 3을 곱함

```C++
int main()
{
    int a;
    int b;

    b = a * 3;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.3.2. 결과

*****

```txt
유저가 입력한 수 X 3
```

#### 8.1.1.4. `/`

*****

> 나누기

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈다.

##### 8.1.1.4.1. 예시

*****

a를 3으로 나눔

```C++
int main()
{
    int a;
    int b;

    b = a / 3;

    cin >> a;
    cout << b;

    return 0;
}
```

##### 8.1.1.4.2. 결과

*****

```txt
유저가 입력한 수를 3으로 나눈 수
```

#### 8.1.1.5. `%`

*****

> 나머지

왼쪽의 피연산자를 오른쪽의 피연산자로 나누고, 나머지를 반환한다.

#### 8.1.1.5.1. 예시

*****

a를 3으로 나눈 나머지

```C++
int main()
{
    int a;
    int b;

    b = a % 3;

    cin >> a;
    cout << b;

    return 0;
}
```

#### 8.1.1.5.2. 결과

*****

```txt
유저가 입력한 수를 3으로 나눴을 때의 나머지
```

### 8.1.2. 증감연산자

*****

> 단순히 1을 더하거나, 뺄 때 사용하는 연산자

C++에서 추가된 연산자로, 기호를 두 번 붙이는 것만으로도 등식을 사용할 수 있다.

#### 8.1.2.1. 형태

*****

`++?`, `?++`의 형태로 사용할 수 있다. 여기에서 주의할 점은, 두 형태의 의미가 서로 다르다는 것이다.

각각의 사용법은 다음과 같다.

##### 8.1.2.1.1. `?++`

*****

```txt
?++ = ? + 1
```

##### 8.1.2.1.2. `++?`

*****

```txt
++? = (? + 1)
```

#### 8.1.2.2. 종류

*****

큰 형태와 의미는 `?++`와 `?--`가 비슷하고, `++?`와 `--?`가 비슷하기 때문에, `?++`, `?--`에 대해서만 작성한다.

##### 8.1.2.2.1. `a++`,

*****

> 더하기

`a + 1`과 같은 용도이다.

###### 8.1.2.2.1.1. 예시

*****

```C++
int main()
{
    cout << 1++;

    return 0;
}
```

###### 8.1.2.2.1.2. 결과

*****

```txt
2
```

##### 8.1.2.2.2. `--`

*****

> 빼기

`a - 1`과 같은 용도이다.

###### 8.1.2.2.2.1. 예시

*****

```C++
int main()
{
    cout << 3--;

    return 0;
}
```

###### 8.1.2.2.2.2. 결과

*****

```txt
2
```

### 8.1.3. 논리연산자

*****

#### 8.1.3.1. `&&`

*****

`그리고`라는 뜻이다.

논리식이 모두 참이면 참을 반환한다.

##### 8.1.3.1.1. 예시

*****

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << endl;
        cout << i + 1 << "번째 번호: ";
        cin >> tagWand[i];
        cout << endl << endl;
    }
    if (tagWand[i] == 1 && tagWand[i] == 3)
    {
        cout << "축하합니다! 번호를 모두 맞추셨습니다!";
    }
    else
    {
        cout << "번호를 맞추지 못했습니다.";
    }   

    return 0;
}
```

##### 8.1.3.1.2. 결과

*****

> 1, 2를 차례대로 모두 쓴 경우

```txt
숫자를 모두 쓰셨습니다.
```

> 순서를 하나라도 맞추지 못한 경우

```txt
번호를 맞추지 못했습니다.
```

#### 8.1.3.2. `||`

*****

> 그리고

논리식 중에서 하나라도 참이면 참을 반환한다.

##### 8.1.3.2.1. 예시

*****

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << i + 1 << "번째 번호 선택: ";
        cin >> tagWand[i];
        cout << endl;
    }
    if (tagWand[i] == 1 || tagWand[i] == 3)
    {
        cout << "축하합니다! 맞춘 번호가 있습니다!" << endl;
    }
    else if (tagWand[i] != 1 && tagwand[i] != 3)
    {
        cout << "맞춘 번호가 하나도 없습니다." << endl;
    }    

    return 0;
}
```

##### 8.1.3.2.2. 결과

*****

> 맞춘 번호가 하나라도 있는 경우

```txt
축하합니다! 맞춘 번호가 있습니다!
```

> 맞춘 번호가 하나도 없는 경우

```txt
맞춘 번호가 하나도 없습니다.
```

#### 8.1.3.3. `!`

*****

> 아니다

논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환한다.

##### 8.1.3.3.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
    int a = 0;
    cin >> a;
    if (a != 1)
    {
        cout << "1이 아닙니다." << endl;
    }

    return 0;
}
```

##### 8.1.3.3.2. 결과

*****

> a가 1이 아닌 경우

```txt
1이 아닙니다.
```

### 8.1.4. 대입연산자

*****

#### 8.1.4.1. `=`

*****

왼쪽의 피연산자에 오른쪽의 피연산자를 대입한다.

##### 8.1.4.1.1. 예시

*****

```C++
int main()
{
    int a = 0;

    a = 1;

    cout << a;

    return 0;
}
```

##### 8.1.4.1.2. 결과

*****

```txt
1
```

#### 8.1.4.2. `+=`

*****

왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.2.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a += 2;
	cout << a;

	return 0;
}
```

##### 8.1.4.2.2. 결과

*****

```txt
3
```

#### 8.1.4.3. `-=`

*****

왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.3.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a -= 2;
	cout << a;

	return 0;
}
```

##### 8.1.4.3.2. 결과

*****

```txt
-1
```

#### 8.1.4.4. `/=`

*****

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결과를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.4.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a /= 3;

	cout << b;

	return 0;
}
```

##### 8.1.4.4.2. 결과

*****

```txt
3
```

#### 8.1.4.5. `%=`

*****

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입한다.

##### 8.1.4.5.1. 예시

*****

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a %= 3;

	cout << b;

	return 0;
}
```

##### 8.1.4.5.2. 결과

*****

```txt
0
```

### 8.1.5. 비교연산자

*****

우리가 수학에서 확인할 수 있는 일반적인 부등호의 그것과 같다.

다만, `크거나 같다(이상)`, `작거나 같다(이하)`의 경우에는 수학 기호와 표기법이 약간 다르다.

#### 8.1.5.1. `>`

*****

왼쪽에 있는 값이 오른쪽보다 크다는 의미이다.

#### 8.1.5.2. `<`

*****

왼쪽에 있는 값이 오른쪽보다 작다는 의미이다.

#### 8.1.5.3. `<=`

*****

왼쪽에 있는 값이 오른쪽보다 작거나 같다는 의미이다.

#### 8.1.5.4. `>=`

*****

왼쪽에 있는 값이 오른쪽보다 크거나 같다는 의미이다.

### 8.1.6. 비트연산자

***

컴퓨터에서 모든 수는 2진수이고, 한 자리는 1 bit이다. 비트연산자는 이 비트 단위로 특정한 연산을 수행한다.

#### 8.1.6.1. `&`

***

> 값이 모두 1이면 1을 반환한다.

#### 8.1.6.2. `|`

***

> 값 두 개 중에서 하나라도 1이면 1을 반환.

#### 8.1.6.3. `^`

***

> 두 개가 다르면 1, 같으면 0.

#### 8.1.6.4. `~`

***

있다라는 정도만 알아두도록 하자.

#### 8.1.6.5. `?`

***

> 삼향연산자.
> 간단하게 처리할 수 있는 `if`문 대용으로 사용한다.
> 생각보다 자주 사용한다.

##### 8.1.6.5.1. 사용법

***

```txt
값을_담을_변수 = (조건식) ? 조건식이_true일때 : 조건식이_false일때
```

##### 8.1.6.5.2. 예시

***

```C++
struct Number;
{
  int str;
}
Number num;

num.str

cout << (1 > 0) ? "hello" : "world" << endl;
```

#### 8.1.6.6. `,`

***

> 쉼표연산자

#### 8.1.6.7. `sizeof`

***

자료형의 바이트 수 변환