# 목차

+ [I. C와 C++에서 모두 사용하는 것들](#c와-c++에서-모두-사용하는-것들)
  - [1. 이스케이프 시퀸스란?](#이스케이프-시퀸스란?)
  - [2. 코드 예시_이스케이프 시퀸스](#코드-예시_이스케이프-시퀸스)
  - [3. 결과_이스케이프 시퀸스](#결과_이스케이프-시퀸스)
+ [II. C에서의 입력](#c에서의-입력)
  - [1. 사용하는 식_c에서의 입력](#사용하는-식_c에서의-입력)
  - [2. 코드 예시_c에서의 입력](#코드-예시_c에서의-입력)
+ [III. C++에서의 입출력](#c++에서의-입출력)
  - [1. 사용하는 식_C++에서의 입출력](#사용하는-식_c++에서의-입출력)
  - [2. 코드 예시_C++에서의 입출력](#코드-예시_c++에서의-입출력)
  - [3. 결과_C++에서의 입출력](#결과_c++에서의-입출력)
+ [IV. 변수](#변수)
  - [1. 변수란?](#변수란?)
  - [2. 변수의 구분](#변수의-구분)
  - [3. 변수의 생성](#변수의-생성)
  - [4. 변수명 생성 규칙](#변수명-생성-규칙)
+ [V. 상수](#상수)
  - [1. 상수란?](#상수란?)
  - [2. 상수의 종류](#상수의-종류)
  - [3. 사용법_상수](#사용법_상수)
    - [1) `define` 상수](#`define`-상수)
    - [2) `define` 상수 예시](###`define`-상수-예시)
    - [3)`const` 상수](#`const`-상수)
+ [VI. 캐스팅(형변환)](#캐스팅(형변환))
  - [1. 캐스팅(형변환)이란?](#캐스팅(형변환)이란?)
  - [2. 주의할 점_캐스팅(형변환)](#주의할-점_캐스팅(형변환))
  - [3. 사용법_캐스팅(형변환)](#사용법_캐스팅(형변환))
  - [4. 코드 예시_캐스팅(형변환)](#코드-예시_캐스팅(형변환))
  - [5. 결과_캐스팅(형변환)](#결과_캐스팅(형변환))
+ [VII. 연산자](#연산자)
  - [1. 연산자의 종류](#연산자의-종류)
    - [1) 산술연산자](#산술연산자)
    - [2) 증감연산자](#증감연산자)
    - [3) 논리연산자](#논리연산자)
    - [4) 대입연산자](#대입연산자)
    - [5) 비교연산자](#비교연산자)
+ [VIII. 제어문](#제어문)
  - [1. 제어문의 구성](#제어문의-구성)
  - [2. 조건문 `if`](#조건문-`if`)
    - [1) 예시_조건문 `if`](#예시_조건문-`if`)
  - [2. 조건문 `switch`](#조건문-`switch`)
    - [1) switch 문의 구성](#`swhitch`-문의-구성)
    - [2) `if`와의 차이점](#`if`와의-차이점)
  - [3. 반복문 while](#반복문-`while`)
    - [1) 사용법_반복문 `while`](#사용법_반복문-`while`)
  - [4. 반복문 `do~while`](#반복문-`do~while`)
    - [1) 사용법_반복문 `while`](#사용법_반복문-`while`)
    - [2)`while`과의 차이점](#`while`과의-차이점)
  - [5. 반복문 `for`](#반복문-`for`)
    - [1) 사용법_반복문 `for`](#사용법_반복문-`for`)





# C와 C++에서 모두 사용하는 것들
---
## 이스케이프 시퀸스란?

역슬래시하고 쓰는 것들
대표적인 예시: \t, \n, \v, ...
1. __\t 예시__
    + "Tab"을 사용해주는 이스케이프 시퀸스이다.
2. __\n 예시__
    + 줄바꿈 기능용 이스케이프 시퀸스이다.
    + Cpp에서는 보통 `endl`을 더욱 많이 사용한다.

## 코드 예시_이스케이프 시퀸스

```C++
#include <iostream>
#include <time.h>
#include "Windows.h"
#include <string>

void C_and_Cpp_both()
{
    //\t의 경우
    cout << "\" << "t 예시: " << endl;
    cout << "안녕하세요\t저는\t사람입니다." << endl << endl;
    cout << "============================" << endl << endl;

    //\n의 경우
    cout << "\" << "n 예시: " << endl;
    cout << "안녕하세요\n저는\n사람입니다." << endl << endl;
}

int main()
{
    C_and_Cpp_both();

    return 0;
}
```
" " 안쪽에 용도에 맞는 이스케이프 시퀸스를 작성한다.



## 결과_이스케이프 시퀸스
```
\t의 경우
---
안녕하세요   저는  사람입니다.


\n의 경우
---
안녕하세요
저는
사람입니다.
```

---


# C에서의 입력

출력은 안에 이미 값이 있기 때문에 얼마만큼을(크기) 출력하면 되는가에 대해서 미리 알 수 있다.

입력을 받을 때에는 유저가 얼마만큼을 입력할지를 가늠할 수 가 없다.

+ 아이디 만들 때: 2글자, 4글자, 5글자, ... 예상할 수 없다.

## 사용하는 식_C에서의 입력

입력:
```C++
scanf("서식문자", 입력받을 내용의 주소값);
```
출력:
```C++
printf("서식문자", 출력할 내용의 주소값);
```

## 코드 예시_C에서의 입력
```C++
#include "stdio.h"//C++에서의 입출력

int main()
{
    int num;//입력받아서 담아둘 변수

    scanf_s("%d", &num);//입력
    printf("%d", num);//출력
}
```

---

# C++에서의 입출력

## 사용하는 식_C++에서의 입출력

C++에서 입출력을 사용하기 위해서는 다음 식을 포함시켜야 한다.

```C++
#include <iostream>
using namespace std;
```

입력:
```C++
cin >> 선언한 변수;
```

출력:
```C++
cout << " " << 선언한 변수
```

## 코드 예시_C++에서의 입출력

```C++
#include <iostream>
using namespace std;

int main()
{
    int num = 0;

    cin >> num; //num에 정수 대입
    cout << "당신이 선택한 수에 2를 더하면" << endl;//문장 + 줄바꿈
    cout << num + 2 << endl;//num + 2, 그리고 줄바꿈

    return 0;
}
```

## 결과_C++에서의 입출력

```txt
당신이 선택한 수에 2를 더하면 num + 2
```

---

# 변수

## 변수란?

+ 변할 수 있는 수
+ 데이터(data)를 저장할 수 있는 메모리 공간
+ 데이터를 저장하기 위해 프로그램에 의해서, 이름을 할당받은 메모리 공간

## 변수의 구분

변수는 크게 __정수형 변수__ 와 __실수형 변수__ 로 구분한다.

이를 __타입(또는 자료형)__ 이라고 부른다.

1. 정수형
    + char(캐릭터): 1byte signed 변수
    + int(integer): 1byte signed 변수
2. 실수형
    + float: 4byte signed 변수
    + double: 8byte signed 변수

## 변수의 생성

__변수의 선언:__
```txt
자료형 변수명;
```
-
__예시:__
```C++
int Number;
```

변수는 함수의 안에도, 밖에도 선언할 수 있다.

## 변수명 생성 규칙
<span style="color:red">
__아래의 내용은 반드시 지켜져야만 한다.__
</span>

1. 알아보기 쉽게 지어야 한다.
2. 변수 이름은 영어와 언더바(_)로만 구성한다.
3. 숫자는 변수에서 가장 처음에 올 수 없다.
    + 예시:
    `1Number` (X)
    `Number1` (O)
4. 공백을 넣을 수 없다.
공백을 반드시 넣어야 한다면, 언더바(_)를 사용한다.
    + 예시:
    `Player Name` (X)
    `Player_Name` (O)
5. 변수명 길이에는 제한이 없다.
6. 선언하고자 하는 변수의 타입(자료형)이 같다면, 한 번에 묶어서 복수의 변수를 선언할 수도 있다.

    + __예시:__
옳은 경우:
`int a, b;`
틀린 경우:
`int a, float b;`
7. 선언과 동시에 초기화할 수 있다.
여러 변수를 한 번에 복수 선언을 하는 경우에도 선언과 동시에 초기화를 하는 것이 가능하다.
    + __예시(한 번에 하나만 선언하는 경우):__
    `int a = 0;`
    + __예시(한 번에 여러 개를 복수 선언하는 경우):__
    `int a, b = 0;`

---

# 상수

## 상수란?
1. 변수와 똑같이 데이터를 저장할 수 있는 메모리 공간.
2. 데이터를 저장하기 위해 프로그램에 의해서, 이름을(받을 수도 있고 받지 않을 수도 있다) 할당받은 메모리 공간.
3. 수학적 개념; 1, 2, 3, 4, 5, ...

## 상수의 종류

__리터럴 상수:__ 이름을 할당받지 않는 상수

__심볼릭 상수:__ 이름을 할당받는 상수

__define 상수, const 상수__

+ __define 상수:__ 전역 상수
+ __const 상수:__ 전역, 지역, 정적 상수

## 사용법_상수

### define 상수
`#define 상수명 상수값`
define 문에는 `;`가 붙지 않는다.
`#define`을 통해 선언한 값은 함부로 바꾸려고 해서는 안된다. 바꾸기 위해서는 반드시 0으로 초기화한 다음 사용해야 한다.

#### deFine 상수 예시
```C++
#include <iostream>
using namespace std;

int main()
{
    #define NUMBER = 100

    NUMBER = 0;
    cin >> NUMBER;
    cout << NUMBER;

    return 0;
}
```

### const 상수
`const 자료형 상수명 = 상수`

---

# 캐스팅(형변환)

## 캐스팅(형변환)이란?

1. 자료형을 변환시키는 방법.

## 주의할 점_캐스팅(형변환)

1. 자료형을 자동으로 변환해주지만, 자동으로 변환할 때 오류가 발생할 수도 있다.
2. 함수와 연관해서 많이 사용된다.
    + __숫자 --> 문자__ 는 가능하지만, __문자 --> 숫자__ 는 불가능하다.
    + __숫자 --> 숫자__ 는 가능하다.
    보통은 정수를 실수로, 실수를 정수로 바꿀 때 사용한다.
    + __문자 --> 문자__ 는 사용할 일이 없다.
    + byte 수를 알아야 한다.
        - __작은 byte --> 큰 byte__ 는 가능하다.
        - __큰 byte --> 작은 byte__ 는 가능하지만, 손실이 발생한다.

## 사용법_캐스팅(형변환)

```txt
(변경할 자료형)변수명
```

## 코드 예시_캐스팅(형변환)
만약 함수의 인자값으로 float형을 요구하는데, 보낼 인자값이 int인 경우 int형에서 float형으로 변환해서 인자값으로 보내주어야 한다.

```C++
#include <iostream>
#include <string>
using namespace std;

int main()
{
	float i = 4.5;
	i = (int)i;
	cout << i;

    return 0;
}
```

## 결과_캐스팅(형변환)

```txt
4
```

만약 중간에 `i = (int)i;`를 통해 `float`형이었던 `i`를 `int`형으로 바꾸지 않았다면, 맨 처음 선언했던 실수인 '4.5'가 그대로 출력되었을 것이다.

하지만 중간에 `int`형으로 바꾸어주었기 때문에 소수점이 삭제되었다. 따라서 출력된 수는 '4' 이다.

---

# 연산자

## 연산자의 종류

### 산술연산자

일반적인 산술(더하기, 빼기, 나누기, 곱하기 등)을 표현하기 위한 연산자들.

#### `+`

더하기. 왼쪽의 피연산자에 오른쪽의 피연산자를 더한다.

예시: a에 1을 더함

```C++
int main()
{
    int a;
    int b;

    b = a + 1;

    cin >> a;
    cout << b;

    return 0;
}
```
#### `-`

빼기. 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀다.

예시: a에서 2를 뺌

```C++
int main()
{
    int a;
    int b;

    b = a - 2;

    cin >> a;
    cout << b;

    return 0;
}
```

#### `*`

곱하기. 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한다.

예시: a에 3을 곱함

```C++
int main()
{
    int a;
    int b;

    b = a * 3;

    cin >> a;
    cout << b;

    return 0;
}
```

#### `/`

나누기. 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈다.

예시: a를 3으로 나눔

```C++
int main()
{
    int a;
    int b;

    b = a / 3;

    cin >> a;
    cout << b;

    return 0;
}
```

#### `%`

나머지. 왼쪽의 피연산자를 오른쪽의 피연산자로 나누고, 나머지를 반환한다.

예시: a를 3으로 나눈 나머지

```C++
int main()
{
    int a;
    int b;

    b = a % 3;

    cin >> a;
    cout << b;

    return 0;
}
```

### 증감연산자

C++에서 추가된 연산자로, 기호를 두 번 붙이는 것만으로도 등식을 사용할 수 있다.

`++a`, `a++`의 형태로 사용할 수 있다.

두 사용 방법의 차이는 각각 다음과 같다.

```
/*`++`의 경우*/
++a = (a + 1);
a++ = a + 1;

/*`--`의 경우*/
--a = (a - 1);
a-- = a - 1;
```

#### `++`

더하기. `a + 1`과 같은 용도이다.

```C++
int main()
{
    cout << 1++;

    return 0;
}
```
결과: `2`


#### `--`

빼기. `a - 1`과 같은 용도이다.

```C++
int main()
{
    cout << 3--;

    return 0;
}
```
결과: `2`

### 논리연산자

#### `&&`

`그리고`라는 뜻이다.

논리식이 모두 참이면 참을 반환한다.

예시:

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << endl;
        cout << i + 1 << "번째 번호: ";
        cin >> tagWand[i];
        cout << endl << endl;
    }
    if (tagWand[i] == 1 && tagWand[i] == 3)
    {
        cout << "축하합니다! 번호를 모두 맞추셨습니다!";
    }
    else
    {
        cout << "번호를 맞추지 못했습니다.";
    }   

    return 0;
}
```

결과:

(1, 2를 차례대로 모두 쓴 경우)

`숫자를 모두 쓰셨습니다.`

#### `||`

`그리고`와 같은 의미.

논리식 중에서 하나라도 참이면 참을 반환함.

예시:

```C++
int main()
{
    int tagWand[2]
    for(i = 0; i < 2; i++)//2번 반복
    {
        cout << i + 1 << "번째 번호 선택: ";
        cin >> tagWand[i];
        cout << endl;
    }
    if (tagWand[i] == 1 || tagWand[i] == 3)
    {
        cout << "축하합니다! 맞춘 번호가 있습니다!" << endl;
    }
    else if (tagWand[i] != 1 && tagwand[i] != 3)
    {
        cout << "맞춘 번호가 하나도 없습니다." << endl;
    }    

    return 0;
}
```

#### `!`

`아니다`라는 의미이다.

논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환한다.

예시:

```C++
#include <iostream>
using namespace std;

int main()
{
    int a = 0;
    cin >> a;
    if (a != 1)
    {
        cout << "1이 아닙니다." << endl;
    }

    return 0;
}
```
결과: a가 1이 아닌 경우

`1이 아닙니다.`

### 대입연산자

#### `=`

왼쪽의 피연산자에 오른쪽의 피연산자를 대입한다.

예시:

```C++
int main()
{
    int a = 0;

    a = 1;

    cout << a;

    return 0;
}
```

결과: `1`

#### `+=`

왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과를 왼쪽의 피연산자에 대입한다.

예시:

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a += 2;
	cout << a;

	return 0;
}
```

결과: `3`

#### `-=`

왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과를 왼쪽의 피연산자에 대입한다.

예시:

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;

	a = 1;

	a -= 2;
	cout << a;

	return 0;
}
```

결과: `-1`

#### `/=`

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결과를 왼쪽의 피연산자에 대입한다.

예시:

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a /= 3;

	cout << b;

	return 0;
}
```

결과: `3`

#### `%=`

왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입한다.

예시:

```C++
#include <iostream>
using namespace std;

int main()
{
	int a;
	int b;

	a = 9;

	b = a %= 3;

	cout << b;

	return 0;
}
```

결과: `0`

### 비교연산자

우리가 수학에서 확인할 수 있는 일반적인 부등호의 그것과 같다.

다만, `크거나 같다(이상)`, `작거나 같다(이하)`의 경우에는 수학 기호와 표기법이 약간 다르다.

#### `>`

왼쪽에 있는 값이 오른쪽보다 크다는 의미이다.

#### `<`

왼쪽에 있는 값이 오른쪽보다 작다는 의미이다.

#### `<=`

왼쪽에 있는 값이 오른쪽보다 작거나 같다는 의미이다.

#### `>=`

왼쪽에 있는 값이 오른쪽보다 크거나 같다는 의미이다.

---

# 제어문

제어문을 사용하는 이유는 __내가 원하는 결과를 얻기 위해서__ 이다.

프로그램의 순차적인 흐름을 제어해야 하는 경우가 생긴다. 이럴 때 사용하는 명령문을 __제어문__ 이라고 한다.

## 제어문의 구성

+ 조건문
  - `if`
    * `if / else`
    * `if / else if`
  - `switch`
+ 반복문
  - `for`
  - `while`
  - `do ~ while`

## 조건문 `if`

### 예시_조건문 `if`

```C++
if (조건식)
{
    조건식이 참일 때 실행할 내용
    (아니면 실행 X)
}
else if (조건식)
{
    if의 조건문이 거짓이고,
    else if의 조건문이 참일때 실행할 내용
    (아니면 실행 X)
}
else if (조건식)
{
    if, 첫번째 else if의 조건문이 거짓이고
    해당 else if의 조건문이 참일때 실행할 내용
}
else
{
    위의 모든 조건식이 거짓일 때 실행할 내용
}
```

컴퓨터의 해석 과정은 다음과 같이 진행된다.

1. if 조건식이 참인가?
    + __예:__
    실행할 내용을 실행한다. else if 또는 else의 내용과 조건문은 검토하거나 실행하지 않고 건너뛴다.
    + __아니요:__
    else if 조건식을 확인한다.
2. else if 조건식이 참인가?
    + __예:__
    실행할 내용을 실행한다. 하단에 남아있는 else if 또는 else의 내용과 조건문은 검토하거나 실행하지 않고 건너뛴다.
    + __아니요:__
    다음 else if 또는 else를 확인한다.
3. if 또는 else if 중 참인 조건식이 없는 경우
    + else의 실행할 내용을 실행한다.

## 조건문 `switch`

주어진 값의 결과에 따라서 다른 명령을 수행하도록 하는 명령문이다.

### `switch`문의 구성

```C++
switch (/*변수*/)
{
    case /*변수값*/:
    /*실행할 내용*/
    break;

    case /*변수값*/:
    /*실행할 내용*/
    break;

    default
    /*실행할 내용*/
    break;
}
```

#### `default`

+ `switch`문에 나열되어 있는 모든 `case`에 해당하지 않을 때 여기부터 실행한다.
+ `default`의 위치는 반드시 맨 아래가 아니여도 된다.
+ 구문상 반드시 포함해야 하는 것도 아니다.

#### `break`

+ `switch`문의 종료 명령어.
+ `break`가 존재하지 않을 경우 이하 모든 case에 대해 실행한다.



int보다 작은 byte의 변수 `char`, `short`, 열거문(`enum`)과 같은 것들도 조건으로 사용할 수 있다.

`int`, `short`, 열거문(`enum`)의 경우에는 숫자로, `char`의 경우에는 문자로 판단한다.

### `if`와의 차이점

1. 처리속도가 빠르다.
2. 디테일한 조정이 불가능하다.(string 변수 사용 불가능)

## 반복문 `while`

### 사용법_반복문 `while`

```C++
while (/*조건식*/)
{
    /*조건이 true일 때 반복 실행할 내용*/
}
```
<span style = "color:red">
* 주의할 점:

반복 실행할 내용에 증감식을 적어두어야 한다.

</span>

## 반복문 `do~while`

### 사용법_반복문 `do~while`

```C++
do
{
    /*
    조건식이 true일때 이 안의 내용을 반복 실행한다.
    조건식의 결과를 변경해줄 내용이다.
    */
}while (조건식)
```

### `while`과의 차이점

조건식의 위치.
`while`은 조건식이 참일 때 실행할 내용 위에 있고, `do ~ while`은 조건이 참일 때 실행할 내용의 밑에 있다.
따라서 `do ~ while`을 하게 되면 true/false에 상관 없이 무조건 1번은 실행하게 된다.

## 반복문 `for`

while처럼 조건식이 상단에 있는 반복문이다. 따라서, while처럼 내용을 실행하기 전 먼저 true / false를 판단한다.

기본 문법 하나에 초기식, 조건식, 증감식을 전부 포함하기 때문에 오류가 날 가능성이 적다.

그러한 이유로, while보다 간결하게, 보기 쉽게 표현할 수 있다.

### 사용법_반복문 `for`

```C++
#include <iostream>
using namespace std;

int main()
{
	int i;

	for (i = 0; i < 10; i++)
	{
		cout << i + 1 << endl;
	}

	return 0;
}
```

결과:

```txt
1
2
3
4
5
6
7
8
9
10
```

+ __증감식의 조건__: `while`과 동일하게 조건식을 종료할 수 있는, 혹은 영향을 줄 수 있는 식이어야 한다.
